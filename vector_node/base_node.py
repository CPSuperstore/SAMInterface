import abc
import copy
import pickle
import collections
import typing


class BaseNode(abc.ABC):
    def __init__(self, level: int = 0):
        self.children: typing.List[typing.Self] = []
        self.level = level

    @classmethod
    def load(cls, filename: str) -> 'typing.Self':
        with open(filename, 'rb') as f:
            return pickle.loads(f.read())

    def save(self, filename: str):
        with open(filename, 'wb') as f:
            f.write(pickle.dumps(self))

    def pre_order_traversal(self, include_self: bool = True) -> typing.Iterable[typing.Self]:
        """
        Method Partially Generated by ChatGPT
        """
        if include_self:
            yield self

        for child in self.children:
            yield from child.pre_order_traversal()

    def post_order_traversal(self, include_self: bool = True) -> typing.Iterable[typing.Self]:
        """
        Method Partially Generated by ChatGPT
        """
        for child in self.children:
            yield from child.post_order_traversal()

        if include_self:
            yield self

    def level_order_traversal(self, include_self: bool = True) -> typing.Iterable[typing.Self]:
        """
        Method Partially Generated by ChatGPT
        """
        queue = collections.deque([self])

        while queue:
            node = queue.popleft()

            if include_self:
                yield node

            elif node != self:
                yield node

            queue.extend(node.children)

    def get_child_count(self) -> int:
        return len(self.children)

    def get_descendant_count(self, include_self: bool = True) -> int:
        count = 0
        for _ in self.level_order_traversal(include_self=include_self):
            count += 1

        return count

    def copy(self, deep_copy: bool = True) -> 'typing.Self':
        if deep_copy:
            return copy.deepcopy(self)

        else:
            return copy.copy(self)

    def add_child(self, child: typing.Self):
        child.level = self.level + 1

        self.children.append(child)

    def add_children(self, children: typing.List[typing.Self]):
        for child in children:
            child.level = self.level + 1

        self.children.extend(children)
